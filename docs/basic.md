* [Haskell æƒ…å ±åé›†è¡“ - Qiita](https://qiita.com/waddlaw/items/b7ed253db36c6f8a04fc)
* [é †åˆ—åˆ—æŒ™é–¢æ•°ï¼ˆç´ æœ´ãªå®Ÿè£…ï¼‰](http://qiita.com/nobsun/items/babd28fe81ba3b9f304f)
* [SamuelSchlesinger/Gaia](https://github.com/SamuelSchlesinger/Gaia) - An experiment in functional interface design
* [Haskell - $ã®ä»•çµ„ã¿ã‚’è¦—ã„ã¦ã¿ã‚ˆã† - Qiita](https://qiita.com/grainrigi/items/f45b586b4013ffc3814e)
* [Idiomatic Haskell : haskell](https://www.reddit.com/r/haskell/comments/84qs5x/idiomatic_haskell/)
* [Haskell/GHC symbol search cheatsheet](https://github.com/takenobu-hs/haskell-symbol-search-cheatsheet)
* [Layout ãƒ«ãƒ¼ãƒ«ï¼Œ Haskell ã®ã‚ªãƒ•ã‚µã‚¤ãƒ‰ãƒ«ãƒ¼ãƒ«ã«ã¤ã„ã¦](https://bydriv.github.io/blog/layout.html)

## å‹
* [What is the difference between an Algebraic Data Type and an Abstract Data Type?](http://www.reddit.com/r/haskell/comments/38grqx/what_is_the_difference_between_an_algebraic_data/)
* [Either and (,) in Haskell are not arbitrary](http://bitemyapp.com/posts/2015-10-19-either-is-not-arbitrary.html)
* [Why sum and product types?](http://charlieharvey.org.uk/page/sum_and_product_types)
* [Unitå‹ã®ä½•ãŒå‰å¤§ãªã®ã‹èª¬æ˜ã—ã¦ã¿ã‚‹](http://qiita.com/alucky0707/items/a677e5c9850aa765dd55)
* [Add a type parameter! One 'simple' design change, a panoply of outcomes](https://www.youtube.com/watch?v=BHjIl81HgfE)
* [The 6 types of Haskell users](http://rickdzekman.com/thoughts/the-6-types-of-haskell-users/)
* [Learning Haskell by Type (Signatures)](http://holger-peters.de/haskell-by-types.html)
* [ãƒ©ãƒ ãƒ€è¨ˆç®—ã§ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ç¾ã™ã‚‹æ–¹æ³•](http://d.hatena.ne.jp/syamino/20120524/p1)
* [Associated Types and Haskell](http://amixtureofmusings.com/2016/05/19/associated-types-and-haskell/)
* [Better Data Types a la Carte](http://reasonablypolymorphic.com/blog/better-data-types-a-la-carte)
* [Sean Seefried - The Joy of Refactoring with Strong, Static Types](https://www.youtube.com/watch?v=_K6UAq4hjAs)
* [USING TYPES EFFECTIVELY](http://www.elbeno.com/presentations/using-types-effectively/presentation.html#/sec-title-slide)
* [Poop deprecation and shitty code](http://cs-syd.eu/posts/2016-08-28-poop-deprecation.html)
* [Maybe](http://qiita.com/knknkn1162/items/48427aee35bd5892c61d)
* [Pattern Synonyms](https://kseo.github.io/posts/2016-12-22-pattern-synonyms.html)
* [YOW! Lambda Jam 2016 Conor McBride - What are Types for, or are they only Against? - YouTube](https://www.youtube.com/watch?v=3U3lV5VPmOU&feature=share)
* [ã€Haskellã€‘ è¨€è‘‰ã®å®šç¾©ã¾ã¨ã‚ï¼ˆå‹ã‚¯ãƒ©ã‚¹ã€å‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€å€¤ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€å‹å¼•æ•°ãªã©ï¼‰ - takafumi blog](http://takafumi-s.hatenablog.com/entry/2015/09/25/123335)
* [Haskell ã«ã‚ˆã‚‹å‹å®‰å…¨ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®å®Ÿè£…ä¾‹(å’Œæš¦) - Qiita](http://qiita.com/algas/items/9e63f7a99303d27a6c03)
* [why-types/why-types.pdf at master Â· skaslev/why-types](https://github.com/skaslev/why-types/blob/master/why-types.pdf)
* [These, Align, and Crosswalk](http://teh.id.au/posts/2017/03/29/these-align-crosswalk/index.html)
* [Maybe? Use a type parameter!](http://www.parsonsmatt.org/2017/04/08/maybe_use_a_type_parameter.html)
* [Generalizing Type Signatures - Michael Snoyman's blog](http://www.snoyman.com/blog/2017/04/generalizing-type-signatures)
* [Well-typed printfs cannot go wrong â€“ ( )](http://kcsongor.github.io/purescript-safe-printf/)
* [Type Safety Back and Forth](http://www.parsonsmatt.org/2017/10/11/type_safety_back_and_forth.html)
* [Haskell equality table](https://htmlpreview.github.io/?https://github.com/quchen/articles/blob/master/haskell-equality-table.html)
* [Type-Directed Code Generation](http://reasonablypolymorphic.com/blog/type-directed-code-generation)
* [Refactoring and Finding the Right Data Structure \| Haskell at Work](https://haskell-at-work.com/episodes/2018-03-08-refactoring-and-finding-the-right-data-structure.html)
* [Haskellã§Union typeã‚’å®Ÿç¾ã™ã‚‹open-unionã‚’ä½¿ã£ã¦ã¿ã¾ã—ãŸ - Qiita](https://qiita.com/nwtgck/items/03e0817ceda5c4b60957)
* [QuasiQuoteã§open-unionã‚’æ›¸ãã‚„ã™ãã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½œã£ã¦ã¿ã¾ã—ãŸ - Qiita](https://qiita.com/nwtgck/items/002817daa0e90e72870b)
* [äººé–“ãŒå‹ã ã‘æ›¸ã‘ã°å®Ÿè£…ã‚’æ„è­˜ã—ãªã„ã§ã‚‚ã‚ˆããªã‚‹æœªæ¥ - Qiita](https://qiita.com/arowM/items/b92075627ddb4ad92d1e)
* [Type Isomorphism](https://kseo.github.io/posts/2016-12-25-type-isomorphism.html)
* [Compose Tetris](https://medium.com/@fintan.halpenny/compose-tetris-196b70035aff)
* [æœ¬å½“ã¯ã™ã”ã„ newtype - Speaker Deck](https://speakerdeck.com/konn/ben-dang-hasugoi-newtype)
* [ã™ã”ã„Hæœ¬ã§è¦‹è½ã¨ã—ãŒã¡ã ãŒå®Ÿã¯é‡è¦ãªæ©Ÿèƒ½ï¼šnewtype - Qiita](https://qiita.com/HirotoShioi/items/70cd235e93dee99bf8e8)
* [ã€Œæ··ãœã‚‰ã‚Œãªã„æ•°ã€ã‚’Haskell/GHCã®å‹ã‚’ä½¿ã£ã¦æ‰‹è»½ã«ã¤ãã‚‹ - Qiita](https://qiita.com/takenobu-hs/items/14101cabf313e6d594ca)
* [Keep your types small...](http://www.parsonsmatt.org/2018/10/02/small_types.html)
* [ã ã‚Œã‚‚ Data.Maybe ã‚’æ•™ãˆã¦ãã‚Œãªã‹ã£ãŸ - Qiita](https://qiita.com/mtsugawa/items/e410812567e8b5b1690c)
* [æ„å¤–ã¨çŸ¥ã‚‰ãªã„Type defaulting - Qiita](https://qiita.com/takoeight0821/items/6cf286bf29479698e977)
* [The Basic, Practical Benefits of the Haskell Type System](http://mechanical-elephant.com/thoughts/2015-08-10-the-pratical-benefits-of-haskell-typesystem/)
* [Types & Kinds](http://slpopejoy.github.io/2015/04/10/Types/)
* [Tag, don't type](https://github.com/quchen/articles/blob/master/tag-dont-type.md)
* [On Ad-hoc Datatypes](https://jaspervdj.be/posts/2016-05-11-ad-hoc-datatypes.html)
* [Ken's blog: [fltalwhq] integerLog2 and an introduction to unboxed types](http://kenta.blogspot.com/2016/09/fltalwhq-integerlog2-and-introduction.html)
* [Dynamic Dispatch in Haskell, or: How Can I Make My Code Extendable? â€“ Two Wrongs](https://two-wrongs.com/dynamic-dispatch-in-haskell-how-to-make-code-extendable)
* [What the heck is polymorphism? - DEV Community ğŸ‘©â€ğŸ’»ğŸ‘¨â€ğŸ’»](https://dev.to/jvanbruegge/what-the-heck-is-polymorphism-nmh)

### ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹
ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã¨ã¯"è¶³ã—ç®—"ã¨"æ›ã‘ç®—"ãŒå‡ºæ¥ã‚‹ã‚ˆã†ãªå‹ã®ã“ã¨ã€‚"è¶³ã—ç®—"ã¨"æ›ã‘ç®—"ã¯ãã‚Œãã‚Œ**ç›´å’Œ**, **ç›´ç©** ã¨å‘¼ã°ã‚Œã‚‹ã€‚

```hs
-- ç›´å’Œ
type a + b = Either a b

-- ç›´ç©
type a * b = (a, b)
```

* [The algebra (and calculus!) of algebraic data types](https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types)
* [The Algebra of Programming in Haskell](http://www.cs.ox.ac.uk/research/pdt/ap/dgp/workshop2004/oliveira.pdf)
* [Why are ADTs necessary?](http://www.reddit.com/r/haskell/comments/2z1n16/why_are_adts_necessary/)
* [Haskell Diary #2 - Algebra of Data Types](http://akashagrawal.me/haskell-diary-2-algebraic-data-types/)
* [Overcoming Boolean blindness with Evidence](http://cs-syd.eu/posts/2016-07-24-overcoming-boolean-blindness-evidence.html)
* [ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã®ãƒ‡ãƒ¼ã‚¿ã®ã¨ã‚Šã†ã‚‹æ•°ã‚’å¾®åˆ†ã™ã‚‹ã¨ï¼‘ç©´ç©ºããƒ‡ãƒ¼ã‚¿å‹ã®æ•°ã«ãªã‚‹è©± - Qiita](http://qiita.com/mittyantest/items/f8783834e6bb48baf2c8)
* [ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã¨Fä»£æ•° - Qiita](http://qiita.com/karrym/items/62c46a2c7640912a1a28)
* [AdÎ±m SchÃ¸nemÎ±nn - Pattern matching ADTs](https://adamschoenemann.dk/posts/2018-05-29-pattern-matching.html)

### Codata
* [Codata](http://types2004.lri.fr/SLIDES/altenkirch.pdf)
* [Data and Codata](http://blog.sigfpe.com/2007/07/data-and-codata.html)
* [Co-data ã€æ–°æ­“ãƒ–ãƒ­ã‚°ãƒªãƒ¬ãƒ¼2017 21æ—¥ç›®ã€‘ | æ±äº¬å·¥æ¥­å¤§å­¦ãƒ‡ã‚¸ã‚¿ãƒ«å‰µä½œåŒå¥½ä¼štraP](https://trap.jp/post/199/)
* [Codata in action, or how to connect Functional Programming and Object Oriented Programming](http://www.javiercasas.com/articles/codata-in-action)

### Zipper
* [zipper](https://hackage.haskell.org/package/zipper)
* [Zippers - LYAH](http://learnyouahaskell.com/zippers)
* [ãƒ‡ãƒ¼ã‚¿å‹ã®å¾®åˆ†](http://ja.wikibooks.org/wiki/Haskell/Zippers#.E3.83.87.E3.83.BC.E3.82.BF.E5.9E.8B.E3.81.AE.E5.BE.AE.E5.88.86)
* [Zippers, Part 2: Zippers as Derivatives](https://pavpanchekha.com/blog/zippers/derivative.html)
* [Scrap Your Zippers](http://michaeldadams.org/papers/scrap_your_zippers/ScrapYourZippers-2010.pdf)
* [syz](https://hackage.haskell.org/package/syz)
* [Zipperé–¢é€£ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸](http://d.hatena.ne.jp/debug-ito/20161016/1476587232)
* [Zipperã«æŒ‘ã‚€](https://qiita.com/Aruneko/items/dee20161358e7c39e27a)
* [Derivatives of Containers](http://www.cs.le.ac.uk/people/mabbott/docs/derivative.pdf)
* [Dan Ghica's Blog: Zippers for non-inductive types](http://danghica.blogspot.com/2018/11/zippers-for-non-inductive-types.html)

### ã‚«ã‚¤ãƒ³ãƒ‰
* [About kind system of Haskell (Part 1)](https://haskell.jp/blog/posts/2017/10-about-kind-system-part1.html)
* [Haskellã®ç¨®(kind)ã«ã¤ã„ã¦ (Part 2)](https://haskell.jp/blog/posts/2017/13-about-kind-system-part2.html)
* [Haskell's kind system - a primer Â· dcastro](https://diogocastro.com/blog/2018/10/17/haskells-kind-system-a-primer/)

### å‹ä»˜ã‘

> 1. Type annotations for an external function may require not only its type structure, but also references to the type names or implementations (i.e. import of modules where these types are declared).
> 2. Partial type signatures still require the type structure of the function (making use of the scaffold of the type signature).
> 3. Visible type applications is the tersest and cleanest way to annotate an external functionâ€™s type. It does not require re-building of the type signature in case of ambiguity.
> 
> [Ğ¢ĞµÑ…-Ğ”ĞµÑ‚Ğ°Ğ»Ğ¸: Type annotations vs partial type signatures vs visible type applications](https://lin-techdet.blogspot.com/2018/12/type-annotations-vs-partial-type.html)


## é–¢æ•°
* [A simple Haskell function](http://neilmitchell.blogspot.jp/2016/01/a-simple-haskell-function.html)
* [Composing bijections, surjections, and injections](https://gist.github.com/rampion/f20ffd6386269e6f7e41fae15d208e12)
* [Eastman maximal comma-free codes in Haskell](https://byorgey.wordpress.com/2016/07/07/eastman-maximal-comma-free-codes-in-haskell/)
* [Descriptive Variable Names: A Code Smell](http://degoes.net/articles/insufficiently-polymorphic)
* [mapé–¢æ•°](http://qiita.com/knknkn1162/items/92de8dd250ff94cd86f1)
* [zudov/24-days-of-syntactic-witchery: Aligning characters for fun and profit, with Haskell and PureScript](https://github.com/zudov/24-days-of-syntactic-witchery)
* [ç¾è¡“ã®äººãŒè€ƒãˆã‚‹ Haskell - Qiita](https://qiita.com/hitsujisanmeme/items/e14972cfd349c1149d58)
* [Haskellã®($)ã¨(.)ã®é•ã„ - Qiita](https://qiita.com/TTsurutani/items/201200c1f288b0d03e78)
* [Another Approach to Default Function Parameters](https://ocharles.org.uk/blog/posts/2015-07-23-another-approach-to-default-variables.html)
* [Ceci n'est pas un default](https://gallais.github.io/blog/ceci-pas-default)
* [Return a Function to Avoid Effects](https://www.parsonsmatt.org/2019/03/22/return_a_function_to_avoid_effects.html)
* [Haskell ã§ã€Œã‚¨ãƒ©ãƒˆã‚¹ãƒ†ãƒã‚¹ã®ç¯©ã€ ãã®ï¼‘ - Qiita](https://qiita.com/little_Haskeller/items/e73d54835b5772a55e81)
* [Haskell ã§ã€Œã‚¨ãƒ©ãƒˆã‚¹ãƒ†ãƒã‚¹ã®ç¯©ã€ ãã®ï¼’ - Qiita](https://qiita.com/little_Haskeller/items/a3ec4c82c7099f1c9cf1)
* [Haskellã®é–¢æ•°ã®å‹ã¨ã‹ã‚«ãƒªãƒ¼åŒ–ã¨ã‹ #Haskell - Qiita](https://qiita.com/Tatsuki-I/items/d1d122107da8c1ee121f)

### ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ
* [Pattern matching](http://mbps.hatenablog.com/entry/2014/10/04/010000)
* [PATTERN MATCHING: WOT'S... UH THE DEAL?](http://www.stackbuilders.com/news/pattern-matching-wot-s-uh-the-deal)
* [Pattern and Guard Extensions](https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/pattern-and-guard-extensions)
* [Haskell ã§æ¡ä»¶åˆ†å²](http://qiita.com/rooooomania/items/1623e5b981a30fbc8427)
* [ã‚³ãƒ”ãƒšã—ã¦ã™ãç¢ºèªã§ãã‚‹Haskellã®æ¡ä»¶åˆ†å²](http://qiita.com/nejimakidori/items/f6aedce6308ce5e32914)

### å¤šå¤‰æ•°é–¢æ•°ã¨ã‚«ãƒªãƒ¼åŒ–
* [Curry](https://ro-che.info/ccc/10)
* [Loop School - Curring](http://school.looprecur.com/?video=122330958)
* [Haskell Functions Take One Argument](http://tonymorris.github.io/blog/posts/haskell-functions-take-one-argument/)
* [A taste of Curry](https://jeltsch.wordpress.com/2013/04/27/a-taste-of-curry/)

```haskell
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c
```

> Haskell åˆå¿ƒè€…ã¯æ‹¬å¼§ã°ã‹ã‚Šã® Lisp ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã€‚ä¸­ç´šè€…ã«ãªã‚‹ã¨ã€($) ãŒå¤šããªã‚‹ã€‚ä¸Šç´šè€…(è¨€ã„éãã‹ï¼Ÿ)ã«ãªã‚‹ã¨ã€($) ãŒæ¶ˆãˆã¦ã€(.) ãŒå¤šããªã‚‹ã€‚

å‡ºå…¸: [é–¢æ•°åˆæˆã®å¦™æŠ€](http://d.hatena.ne.jp/kazu-yamamoto/20100702/1278036842)

### ãƒã‚¤ãƒ³ãƒˆãƒ•ãƒªãƒ¼
å¿…è¦ã®ãªã„ã¨ã“ã‚ã§ãƒã‚¤ãƒ³ãƒˆãƒ¯ã‚¤ã‚ºã«æ›¸ãå¿…è¦ã¯ãªã„ãŒã€ã‚ã¾ã‚Šãƒã‚¤ãƒ³ãƒˆãƒ•ãƒªãƒ¼ã«æ‹˜ã‚Šã™ããªã„ã®ã‚‚å¤§äº‹

* [ãƒã‚¤ãƒ³ãƒˆãƒ•ãƒªãƒ¼ã‚¹ã‚¿ã‚¤ãƒ«å…¥é–€](http://d.hatena.ne.jp/melpon/20111031/1320024473)
* [Haskellã®ãƒ•ã‚¯ãƒ­ã‚¦ ((.)$(.))](http://uid0130.blogspot.jp/2014/11/haskell_17.html)
* [Blunt](https://blunt.herokuapp.com/)
  * [pointfree](https://hackage.haskell.org/package/pointfree)
* ["Point-Free or Die: Tacit Programming in Haskell and Beyond" by Amar Shah](https://www.youtube.com/watch?v=seVSlKazsNk)

### é…å»¶è©•ä¾¡
* [SchrÃ¶dinger's cat](https://ro-che.info/ccc/4)
* [RÃ©sumÃ©](https://ro-che.info/ccc/11)
* [æ­£æ ¼è©•ä¾¡ã¨é…å»¶è©•ä¾¡ï¼ˆåŸºæœ¬ç·¨ï¼‰](http://qiita.com/ruicc/items/07143c9e78c697227706)
* [æ­£æ ¼è©•ä¾¡ã¨é…å»¶è©•ä¾¡ï¼ˆè©³ç´°ç·¨ï¼‰](http://qiita.com/ruicc/items/31a269f93404268d80d7)
* [takenobu-hs/lazy_evaluation](https://github.com/takenobu-hs/lazy_evaluation)
* [ãªãœHaskellã§ã‚¿ãƒ©ã‚¤å›ã—ãŒé€Ÿã„ã®ã‹ã€ã‚ã‚‹ã„ã¯é…å»¶è©•ä¾¡ã¨STG](http://qiita.com/ruicc/items/b8b3c61a12baa1af3c69)
* [An example of using laziness](http://noughtmare.gitlab.io/posts/2017-08-30-an-example-of-using-laziness.html)
* [All About Strictness](https://www.fpcomplete.com/blog/2017/09/all-about-strictness)
* [Visualizing lazy evaluation](http://www.well-typed.com/blog/2017/09/visualize-cbn/)
* [Adaptive Evaluation of Non-Strict Programs](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/ennals-thesis.pdf)
* [fixpt - All About Strictness Analysis (part 1)](http://fixpt.de/blog/2017-12-04-strictness-analysis-part-1.html)
* [Thinking Functionally with Haskellå‹‰å¼·ãƒ¡ãƒ¢: ç¬¬ï¼—ç« ï¼‘ã€€ãƒ¡ãƒ¢ãƒªã€è¨ˆç®—é‡ã€`seq` - Arantium Maestum](http://zehnpaard.hatenablog.com/entry/2018/04/01/065836)
* [æ­£æ ¼æ€§ã®ã™ã¹ã¦ (ç¿»è¨³)](https://haskell.e-bigmoon.com/posts/2018/06-25-all-about-strictness)
* [Laziness Quiz](https://www.parsonsmatt.org/2018/12/04/laziness_quiz.html)
* [Haskellã«ãŠã„ã¦é…å»¶è©•ä¾¡ã¯è«¸åˆƒã®å‰£ã§ã‚ã‚Šã€æ³¨æ„ã™ã¹ãã§ã‚ã‚‹ã¨ã„ã†è©± - Qiita](https://qiita.com/HirotoShioi/items/2adca7fa238c5abad6ef)
* [The Incomplete Guide to Lazy Evaluation (in Haskell)](https://hackhands.com/guide-lazy-evaluation-haskell/)
* [If Haskell were strict, what would the laziness be like?](http://nikita-volkov.github.io/if-haskell-were-strict/)
* [How to force a list](https://ro-che.info/articles/2015-05-28-force-list)
* [Thinking with Laziness](http://begriffs.com/posts/2015-06-17-thinking-with-laziness.html)
* [How Laziness Works](http://two-wrongs.com/how-laziness-works)
* [ã•ã‚ˆã†ãªã‚‰é…å»¶è©•ä¾¡ - ã‚ã©ã‘ãªã„è©±](https://kazu-yamamoto.hatenablog.jp/entry/2019/02/15/115630)

> One very interesting comparison is that lazy evaluation is to the CPU what garbage collection is to memory.

å‡ºå…¸: <http://scott.sauyet.com/Javascript/Talk/2014/01/FuncProgTalk/#slide-40>

### ãƒ¡ãƒ¢åŒ–

**é…å»¶è©•ä¾¡ã‚’åˆ©ç”¨ã—ãŸãƒ¡ãƒ¢åŒ–ã®å®Ÿè£…ä¾‹**

```haskell
fibs :: [Integer]
fibs = map fib [0..]

fib :: Int -> Integer
fib 0 = 1
fib 1 = 1
fib n = fibs !! (n-1) + fibs !! (n-2)
```

å‚è€ƒ: [Can someone explain the concept behind Haskell's memoization?](http://programmers.stackexchange.com/questions/220746/can-someone-explain-the-concept-behind-haskells-memoization)

* [Haskell memoization](http://lukahorvat.github.io/programming/2014/11/18/haskell-memoization/)
* [Haskellã§ãƒ¡ãƒ¢åŒ–ã‚’è¡Œã†ã‚‚ã†ä¸€ã¤ã®æ–¹æ³•](http://d.hatena.ne.jp/tanakh/20100411)
* [Kwang's Haskell Blog - Memoization in Haskell](https://kseo.github.io//posts/2017-01-14-memoization-in-hasekll.html)
* [é–¢æ•°ã®ãƒ¡ãƒ¢åŒ–](https://kakkun61.hatenablog.com/entry/2019/07/29/%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%A1%E3%83%A2%E5%8C%96)

### æ­£æ ¼è©•ä¾¡
* [fixpt - All About Strictness Analysis (part 1)](http://fixpt.de/blog/2017-12-04-strictness-analysis-part-1.html)
* [fixpt - All About Strictness Analysis (part 2)](http://fixpt.de/blog/2018-12-30-strictness-analysis-part-2.html)
* [Strictæ‹¡å¼µã§ãƒãƒã£ãŸãŠè©± - Qiita](https://qiita.com/pxfnc/items/a26bda6d11402daba675)

### éƒ¨åˆ†é–¢æ•°
* [Partial Function Considered Harmful](http://tanakh.jp/posts/2011-12-25-partial-function-considered-harmful.html)
* <https://twitter.com/GabrielG439/status/671803691591077888>
* [24 days of Hackage, 2015: day 16: safe; what is safety anyway?](http://conscientiousprogrammer.com/blog/2015/12/16/24-days-of-hackage-2015-day-16-safe-what-is-safety-anyway/)
* [éƒ¨åˆ†é–¢æ•°ã‚’ã©ã†æ‰±ã†ã‹(spoonã®ç´¹ä»‹)](http://qiita.com/techno-tanoC/items/1b725713cd01bdf83b40)
* [The spoon package](https://hackage.haskell.org/package/spoon)

### å¤šç›¸å‹
* [å¤šç›¸é–¢æ•°ã‚’æ•°ãˆã‚‹ - Qiita](http://qiita.com/nobsun/items/5662968f1c381695e7ff)
* [ã€Œå¤šç›¸é–¢æ•°ã‚’æ•°ãˆã‚‹ã€ã‚’è€ƒãˆã‚‹ - Qiita](http://qiita.com/cutsea110/items/3496394968cb7ac73047)
* [ãƒ©ãƒ³ã‚¯2å¤šç›¸ã®ã€ãµãŸã¤ã®å´é¢ - Qiita](http://qiita.com/YoshikuniJujo/items/c28d8fa11e33ed677e83)

---

* [Generalizing function composition](http://jaspervdj.be/posts/2014-10-17-generalizing-function-composition.html)
* [Haskell Symposium 2012. Koen Claessen: Shrinking and showing functions](https://www.youtube.com/watch?v=CH8UQJiv9Q4)
* [Making a fast curry Push/enter vs eval/apply for higher-order languages](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.134.9317&rep=rep1&type=pdf)
* [A Pragmatic Case for Static Typing with Brian Hurt](https://vimeo.com/72870631)
* [On stateless software design: what is state ?](http://www.leonmergen.com/code/2015/12/04/on-stateless-software-design-what-is-state.html)
* [Does Haskell make promises it can't keep? or The big problem with wrapping numeric types](https://gist.github.com/tdoris/de36d2306edc5d6e9e7d#file-promises-md)
* [Haskell/GHC è¨˜å·ã®æ„å‘³ã‚’æ¤œç´¢ã™ã‚‹ãŸã‚ã®ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹é›† - Qiita](https://qiita.com/takenobu-hs/items/b95f0a4409c59440d4a9)
* [Follow the Denotation :: Reasonably Polymorphic](http://reasonablypolymorphic.com/blog/follow-the-denotation/)
* [Combinatorics of Permutations: Introduction](https://vynm.github.io/Comutations/posts/2018-05-25-00Introduction.html)
* [Haskell ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®åŸºç¤çŸ¥è­˜ - Qiita](https://qiita.com/kyotsuya/items/a7015ae5ad413288d8fe)
* [Haskell ã§ã‚‚ heredoc ãŒã—ãŸã„ - Haskell-jp](https://haskell.jp/blog/posts/2019/string-gap-for-heredoc-like.html)
